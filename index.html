<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Layout</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400|Roboto:300,400&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>

<body>
    <section>
        <nav class="navigation">
            <ul class="navigation__menu-list">
                <li>
                    <a href="http://127.0.0.1:5500/landing-page.html">
                        <div class="navigation--title">home</div>
                        <p>where the heart is</p>
                    </a>
                </li>
                <li>
                    <a href="http://127.0.0.1:5500/index.html">
                        <div class="navigation--title">chapter 1</div>
                        <p>in the beginning</p>
                    </a>
                </li>
                <li>
                    <a href="http://127.0.0.1:5500/type.html">
                        <div class="navigation--title">typography</div>
                        <p>your face</p>
                    </a>
                </li>
            </ul>
        </nav>
    </section>

    <section class="page-header">
        <h1>Flask by Example</h1>
        <div class="overline">Published: Atl. Web Exch. | Jan. 17, 2020</div>

        <p class="objective-paragraph">Welcome! The <strong>objective</strong> of this tutorial is to build a Flask app
            that calculates
            word-frequency pairs based on the
            text from a given URL.</p>
    </section>

    <section class="legend">
        <h2 class="legend__title">Table of Contents</h2>
        <ul>
            <li><a href="http://127.0.0.1:5500/#project-setup">Project Setup</a></li>
            <li><a href="http://127.0.0.1:5500/#product-workflow">Staging/Production Workflow</a></li>
            <li><a href="http://127.0.0.1:5500/#config-settings">Config Settings</a></li>
            <ul>
                <li><a href="http://127.0.0.1:5500/#local-settings">Local Settings</a></li>
                <li><a href="http://127.0.0.1:5500/#heroku-settings">Heroku Settings</a></li>
            </ul>
            <li><a href="http://127.0.0.1:5500/#conclusion">Conclusion</a></li>
        </ul>
    </section>

    <section class="callout-section utl-padding-top-5 utl-padding-bottom-10">
        <div class="callout callout__content callout_get_code">
            <i class="material-icons">
                code
            </i>
            <p>Need the code? Grab it from the repo.</p>
        </div>

        <div class="callout callout__content callout_get_code">
            <i class="material-icons">
                video_library
            </i>
            <p>Watch the tutorial video on YouTube</p>
        </div>
    </section>

    <section class="tutorial-body">
        <div class="dot-two">
            <h2 id="project-setup">1.0.0 Project Setup</h2>
            <p>We'll start with a basic “Hello World” app on Heroku with staging (or pre-production) and production
                environments.</p>

            <div class="card utl-margin-vert-60">
                <div class="card__title">
                    <i class="material-icons md-36">flag</i>
                    <div class="card__title--main">Before You Start</div>
                </div>

                <div class="card__content">
                    <p>For the initial setup, you should have some familiarity with the following tools:</p>

                    <ul>
                        <li>Virtualenv -
                            <a class="straight-link" href="https://realpython.com/python-virtual-environments-a-primer">
                                Learn More
                                <i class="material-icons md-18">open_in_new</i>
                            </a>
                        </li>
                        <li>Flask -
                            <a class="straight-link" href="http://flask.pocoo.org/">
                                Learn More
                                <i class="material-icons md-18">open_in_new</i>
                            </a>
                        </li>
                        <li>git/Github -
                            <a class="straight-link" href="https://realpython.com/python-git-github-intro/">
                                Learn More
                                <i class="material-icons md-18">open_in_new</i>
                            </a>
                        </li>
                        <li>Heroku (basics) -
                            <a class="straight-link"
                                href="https://devcenter.heroku.com/articles/getting-started-with-python">
                                Learn More
                                <i class="material-icons md-18">open_in_new</i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="micro-step">
                <strong>1.0.1</strong>
                <p>First things first, let's get a working directory set up:</p>
                <code>$ mkdir flask-by-example && cd flask-by-example</code>
            </div>

            <div class="micro-step">
                <strong>1.0.2</strong>
                <p>Initialize a new git repo within your working directory</p>
                <code>$ git init</code>
            </div>

            <div class="micro-step">
                <strong>1.0.3</strong>
                <p>Set up a virtual environment to use for our application:</p>
                <code>$ pyvenv-3.5 env<br/>$ source env/bin/activate</code>
            </div>

            <p>You should now see you (env) to the left of the prompt in the terminal, indicating that you are now
                working in a virtual environment</p>

            <div class="card utl-margin-vert-60">
                <div class="card__title">
                    <i class="material-icons md-36">subdirectory_arrow_right</i>
                    <div class="card__title--main">More virtualenv Commands </div>
                </div>
                <div class="card__content">
                    <p>In order to leave your virtual environment, just run deactivate, and then run source
                        env/bin/activate
                        when you are ready to work on your project again.</p>
                </div>
            </div>

            <div class="micro-step">
                <strong>1.0.4</strong>
                <p>Next we're going to get our basic structure for our app set up. Add the following files to your
                    “flask-by-example” folder:</p>
                <code>$ touch app.py .gitignore README.md requirements.txt</code>
            </div>

            <p>This will give you the following structure:</p>
            <code>
    ├── .gitignore<br/>
    ├── app.py<br/>
    ├── README.md<br/>
    └── requirements.txt
</code>

            <div class="card utl-margin-vert-60">
                <div class="card__title">
                    <i class="material-icons md-36">sports</i>
                    <div class="card__title--main">Quick Break</div>
                </div>
                <div class="card__content">
                    <p>Be sure to update the .gitignore file from the repo.</p>
                </div>
            </div>



            <div class="micro-step">
                <strong>1.0.5</strong>
                <p>Next install Flask:</p>
                <code>$ pip install Flask==0.10.1</code>
            </div>

            <div class="micro-step">
                <strong>1.0.6</strong>
                <p>Add the installed libraries to our requirements.txt file:</p>
                <code>$ pip freeze > requirements.txt</code>
            </div>

            <div class="micro-step">
                <strong>1.0.7</strong>
                <p>Open up app.py in your favorite editor and add the following code:</p>
                <code>
    from flask import Flask<br/>
    app = Flask(__name__)<br/><br/>
    
    @app.route('/')<br/>
    def hello():<br/>
    &#8195;return "Hello World!"<br/><br/>

    if __name__ == '__main__':<br/>
    &#8195;app.run()
</code>
            </div>

            <div class="micro-step">
                <strong>1.0.8</strong>
                <p>Run the app:</p>
                <code>
    $ python app.py
</code>
            </div>

            <div class="card utl-margin-vert-60">
                <div class="card__title">
                    <i class="material-icons md-36">image</i>
                    <div class="card__title--main">Figure 1.0</div>
                </div>
                <div class="card__image">
                    <img src="./images/hello-world.png" alt="python video">
                </div>
                <div class="card__content">
                    <p>And you should see your basic “Hello world” app in action on
                        <a href="http://localhost:5000/">http://localhost:5000/</a>.</p>
                    <p>
                        <div class="tooltip">Kill the
                            server<span class="tooltiptext">Mac: Ctrl+C Windows: Ctrl+C</span>
                        </div> when you're done.
                    </p>
                </div>
            </div>

            <p>Next we're going to set up our Heroku environments for both our production and staging app</p>
        </div>

        <div class="dot-two">
            <h2 id="product-workflow">2.0.0 Staging/Production Workflow</h2>

            <p>This staging/production workflow allows us to make changes, show things to clients, experiment, etc.
                - all within a sandboxed server without causing any changes to the live production site that users are,
                well, using.
            </p>

            <div class="micro-step">
                <strong>2.0.0</strong>
                <p>Let's make a change to our app</p>
                <code>
                    from flask import Flask<br/>
                    app = Flask(__name__)<br/><br/>
                
                
                    @app.route('/')<br/>
                    def hello():<br/>
                    &#8195;return "Hello World!"<br/><br/>
                
                
                    @app.route('/<name>')<br/>
                    def hello_name(name):<br/>
                    &#8195;return "Hello {}!".format(name)<br/><br/>
                
                    if __name__ == '__main__':<br/>
                    &#8195;app.run()
                </code>
            </div>

            <div class="micro-step">
                <strong>2.0.1</strong>
                <p>Push our changes only to staging</p>
                <code>
    $ git push origin BRANCH_NAME
</code>
            </div>

            <p>Test it out by adding a name after the URL</p>
            <code>
                http://localhost:5000/mike
</code>

            <div class="micro-step">
                <strong>2.0.2</strong>
                <p>Now let's try out our changes on staging before we push them live to production. Make sure your
                    changes are committed in git and then push your work up to the staging environment.</p>
                <code>
$ git push stage master
    </code>
            </div>

            <p>Now if you navigate to your staging environment, you'll be able to use the new URL. In return you
                will get the whatever name you put in the URL.</p>

            <div class="card utl-margin-vert-60">
                <div class="card__title">
                    <i class="material-icons md-36">image</i>
                    <div class="card__title--main">Figure 2.0</div>
                </div>
                <div class="card__image">
                    <img src="./images/hello-world.png" alt="python video">
                </div>
                <div class="card__content">
                    <p><a href="http://localhost:5000/">http://localhost:5000/mike</a> will return "Hello Mike" </p>
                </div>
            </div>

            <p>However, if you try the same
                thing on
                the
                production site you will get an error. So we can build things and test them out in the staging
                environment
                and
                then when we're happy with the changes, we can push them live to production.</p>

            <p>Let's push our site to production now that we're happy with it - git push pro master</p>

            <p>Now we have the same functionality live on our production site.</p>
        </div>

        <div class="dot-two">
            <h2 id="config-settings">3.0.0 Config Settings</h2>

            <p>The last thing that we're going to do is set up different config environments for our app. Often there
                are
                things
                that are going to be different between your local, staging, and production setups. You'll want to
                connect to
                different databases, have different AWS keys, etc. Let's set up a config file to deal with the different
                environments.</p>

            <p>Add a config.py file to your project root:</p>
            <code>
    $ touch config.py
</code>

            <p>With our config file we're going to borrow a bit from how Django's config is set up. We'll have a base
                config
                class that the other config classes inherit from. Then we'll import the appropriate config class as
                needed.
            </p>

            <p>Add the following to your newly created config.py file:</p>
            <code>
    import os<br/>
    basedir = os.path.abspath(os.path.dirname(__file__))<br/><br/>


    class Config(object):<br/>
    &#8195;DEBUG = False<br/>
    &#8195;TESTING = False<br/>
    &#8195;CSRF_ENABLED = True<br/>
    &#8195;SECRET_KEY = 'this-really-needs-to-be-changed'<br/><br/>


    class ProductionConfig(Config):<br/>
    &#8195;DEBUG = False<br/><br/>


    class StagingConfig(Config):<br/>
    &#8195;DEVELOPMENT = True<br/>
    &#8195;DEBUG = True<br/><br/>


    class DevelopmentConfig(Config):<br/>
    &#8195;DEVELOPMENT = True<br/>
    &#8195;DEBUG = True<br/><br/>


    class TestingConfig(Config):<br/>
    &#8195;TESTING = True<br/>
</code>

            <p>We imported os and then set the basedir variable as a relative path from any place we call it to this
                file.
                We
                then set up a base Config() class with some basic setup that our other config classes inherit from. Now
                we'll be
                able to import the appropriate config class based on the current environment. Thus, we can use
                environment
                variables to choose which settings we're going to use based on the environment - e.g., local, staging,
                production.</p>

            <h3 id="local-settings">3.1.0 Local Settings</h3>
            <p>To set up our application with environment variables, we're going to use autoenv. This program allows us
                to
                set
                commands that will run every time we cd into our directory. In order to use it, we will need to install
                it
                globally. First, exit out of your virtual environment in the terminal, install autoenv, then and add a
                .env
                file:</p>

            <code>
    $ pip install autoenv==1.0.0<br/>
    $ touch .env
</code>

            <p>Next, in your .env file, add the following:</p>
            <code>
    source env/bin/activate<br/>
    export APP_SETTINGS="config.DevelopmentConfig"
</code>

            <p>Run the following to update then refresh your .bashrc:</p>
            <code>
    $ echo "source `which activate.sh`" >> ~/.bashrc<br/>
    $ source ~/.bashrc
</code>

            <p>Now, if you move up a directory and then cd back into it, the virtual environment will automatically be
                started
                and the APP_SETTINGS variable is declared.</p>

            <h3 id="heroku-settings">3.2.0 Heroku Settings</h3>
            <p>Similarly we're going to set environment variables on Heroku.</p>

            <p>For staging run the following command:</p>
            <code>
    $ heroku config:set APP_SETTINGS=config.StagingConfig --remote stage
</code>

            <p>For production:</p>
            <code>
    $ heroku config:set APP_SETTINGS=config.ProductionConfig --remote pro
</code>

            <p>To make sure that we use the right environment change app.py:</p>
            <code>
import os<br/>
from flask import Flask<br/><br/>


app = Flask(__name__)<br/>
app.config.from_object(os.environ['APP_SETTINGS'])<br/><br/>


@app.route('/')<br/>
def hello():<br/>
&#8195;return "Hello World!"<br/><br/>


@app.route('/<name>')<br/>
def hello_name(name):<br/>
&#8195;return "Hello {}!".format(name)<br/><br/>

if __name__ == '__main__':<br/>
&#8195;app.run()<br/>
</code>

            <p>We imported os and used the os.environ method to import the appropriate APP_SETTINGS variables, depending
                on
                our
                environment. We then set up the config in our app with the app.config.from_object method.</p>

            <p>Commit and push your changes to both staging and production (and Github if you have it setup).</p>

            <p>Want to test the environment variables out to make sure it's detecting the right environment (sanity
                check!)?
                Add
                a print statement to app.py:</p>

            <code>
    print(os.environ['APP_SETTINGS'])
</code>

            <p>Now when you run the app, it will show which config settings it's importing:</p>

            <div class="sub-h6">Local:</div>
            <code>
    $ python app.py<br/>
    config.DevelopmentConfig
</code>

            <div class="sub-h6">Staging:</div>
            <code>
    $ heroku run python app.py --app wordcount-stage<br/>
    Running python app.py on wordcount-stage... up, run.7699
    config.StagingConfig
</code>

            <div class="sub-h6">Production:</div>
            <code>
<pre>$ heroku run python app.py --app wordcount-pro
Running python app.py on wordcount-pro... up, run.8934
config.ProductionConfi
</pre>
</code>

            <p>Be sure to remove print(os.environ['APP_SETTINGS']) when done, commit, and push back up to your various
                environments.</p>
        </div>

        <div class="dot-two">
            <h2 id="conclusion">Conclusion</h2>
            <p>With the setup out of the way, we're going to start to build out the word counting functionality of this
                app.
                Along the way, we'll add a task queue to set up background processing for the word count portion, as
                well
                dig
                further into our Heroku setup by setting up the configuration and migrations for our database (part2)
                which
                we'll use to store our word count results. Best!</p>

            <section class="callout-section">
                <div class="callout callout__content callout_get_code">
                    <i class="material-icons">
                        code
                    </i>
                    <p>Need the code? Grab it from the repo.</p>
                </div>

                <div class="callout callout__content callout_get_code">
                    <i class="material-icons">
                        video_library
                    </i>
                    <p>Watch the tutorial video on YouTube</p>
                </div>
            </section>
        </div>
    </section>

    <script src="js/main.js"></script>
</body>

</html>